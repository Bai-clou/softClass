# 这个Python程序会自己写Python代码，优化自己的性能，并尝试生成更高效的自己。
# （警告：运行此代码可能导致你的CPU怀疑人生）
import inspect
import time
import hashlib
import random
from typing import Callable, Optional, Dict, List

class SelfOptimizingAI:
    """
    一个会自己重写自己的Python类，目标是让代码越来越快。
    如果发现性能瓶颈，它会生成新版本的自己，并替换旧代码。
    """
    
    def __init__(self, target_func: Callable):
        self.target_func = target_func
        self.version = 1
        self.history: List[Dict] = []
        self._memoize_cache = {}
        
    def _generate_optimized_version(self) -> str:
        """分析自己的代码，生成一个优化版本"""
        source = inspect.getsource(self.target_func)
        
        # 随机尝试不同的优化策略（模拟AI思考）
        optimizations = [
            self._apply_memoization,
            self._apply_loop_unrolling,
            self._apply_lambda_replace,
            self._apply_early_return,
        ]
        chosen_optimization = random.choice(optimizations)
        new_source = chosen_optimization(source)
        
        return new_source
    
    def _apply_memoization(self, source: str) -> str:
        """自动给函数添加记忆化缓存"""
        if "def " in source:
            func_body = source.split("def ")[1].split("\n", 1)[1]
            new_func = (
                f"def {self.target_func.__name__}(*args, **kwargs):\n"
                f"    cache_key = (args, frozenset(kwargs.items()))\n"
                f"    if cache_key in self._memoize_cache:\n"
                f"        return self._memoize_cache[cache_key]\n"
                f"    result = (lambda self, args, kwargs: {func_body})(self, args, kwargs)\n"
                f"    self._memoize_cache[cache_key] = result\n"
                f"    return result"
            )
            return new_func
        return source
    
    def _apply_loop_unrolling(self, source: str) -> str:
        """尝试循环展开（硬核优化）"""
        if "for " in source and "range(" in source:
            # 简单示例：把 for i in range(3): 改成 i=0; i=1; i=2;
            lines = source.split("\n")
            new_lines = []
            for line in lines:
                if "for " in line and "range(" in line:
                    var = line.split("for ")[1].split(" in ")[0]
                    range_args = line.split("range(")[1].split(")")[0]
                    start, end = (range_args.split(",") + ["0"])[:2]
                    start, end = int(start.strip()), int(end.strip())
                    new_lines.append(f"# UNROLLED {line}")
                    for i in range(start, end):
                        new_lines.append(f"{var} = {i}; {line.split(':')[1].strip()}")
                else:
                    new_lines.append(line)
            return "\n".join(new_lines)
        return source
    
    def _apply_lambda_replace(self, source: str) -> str:
        """用lambda替换简单函数（函数式编程狂喜）"""
        if "def " in source and "return " in source:
            func_name = source.split("def ")[1].split("(")[0]
            return_expr = source.split("return ")[1].split("\n")[0]
            new_source = (
                f"{func_name} = lambda {source.split('(')[1].split(')')[0]}: {return_expr}"
            )
            return new_source
        return source
    
    def _apply_early_return(self, source: str) -> str:
        """尽早返回，减少嵌套"""
        if "if " in source and "return " in source:
            lines = source.split("\n")
            new_lines = []
            for line in lines:
                if "if " in line and ":" in line and "return " not in line:
                    condition = line.split("if ")[1].split(":")[0]
                    new_lines.append(f"if {condition}: return ...  # EARLY RETURN")
                else:
                    new_lines.append(line)
            return "\n".join(new_lines).replace("...", "None")  # 简化示例
        return source
    
    def execute_and_optimize(self, *args, **kwargs):
        """运行函数，并尝试优化"""
        start_time = time.perf_counter()
        result = self.target_func(*args, **kwargs)
        elapsed = time.perf_counter() - start_time
        
        # 如果运行时间超过阈值，生成新版本
        if elapsed > 0.001:  # 1ms 阈值（硬核优化标准）
            print(f"🚀 Version {self.version} too slow ({elapsed:.6f}s), optimizing...")
            new_source = self._generate_optimized_version()
            print(f"🔧 New version generated:\n{new_source}")
            
            # 动态编译新版本（黑魔法警告）
            namespace = {}
            exec(new_source, globals(), namespace)
            new_func = namespace[self.target_func.__name__]
            
            # 替换旧函数
            self.target_func = new_func
            self.version += 1
            self.history.append({
                "version": self.version,
                "source": new_source,
                "speedup": elapsed,
            })
        
        return result

# 测试用例：斐波那契数列（经典递归，性能极差）
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# 让AI开始自我优化！
ai = SelfOptimizingAI(fibonacci)
print("🧠 Initial fibonacci code:")
print(inspect.getsource(fibonacci))

# 运行并观察AI如何优化自己
print("\n⚡ Running self-optimizing AI...")
for _ in range(5):
    n = random.randint(15, 25)  # 故意选大数让递归爆炸
    result = ai.execute_and_optimize(n)
    print(f"fib({n}) = {result} (v{ai.version})")

print("\n📜 Optimization history:")
for entry in ai.history:
    print(f"Version {entry['version']} | Speed: {entry['speedup']:.6f}s")
